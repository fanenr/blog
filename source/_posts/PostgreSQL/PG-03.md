---
title: PostgreSQL 03 - DDL
date: 2024-07-30 14:00:00
updated: 2024-07-30 15:00:00
tags:
  - DB
  - PostgreSQL
categories:
  - [DB, PostgreSQL]
---

&emsp;&emsp;PostgreSQL: The World\'s Most Advanced Open Source Relational Database.

<!-- more -->

&emsp;&emsp;DDL (Data Definition Language) 是 SQL (Structured Query Language) 的一部分，用于定义和管理数据库的结构。DDL 语句主要用于创建、修改和删除数据库对象，如表、索引、视图等。

&emsp;&emsp;创建和管理 PostgreSQL 数据库和模式的部分已经总结过了，本节主要总结表对象的管理。

## 创建表

&emsp;&emsp;关系数据库中的表非常像纸上的表格：它由行和列组成。列的数量和顺序是固定的，并且每列都有一个名称。行数是可变的 — 它反映了在给定时刻存储的数据量。SQL 不会对表中行的顺序做出任何保证。读取表时，除非明确请求排序，否则行将按未指定顺序显示。此外，SQL 不会为行分配唯一标识符，因此表中可能有多个完全相同行。

&emsp;&emsp;每列都有一个数据类型。数据类型限制了可以分配给一列的可能值集，并为存储在列中的数据分配语义，以便可用于计算。PostgreSQL 包含很多内置数据类型，用户还可以定义自己的数据类型。

&emsp;&emsp;使用 CREATE TABLE 语句创建一个新表：

```sql
CREATE TABLE products (
    id integer,
    name varchar,
    price numeric
);
```

&emsp;&emsp;至少应指明新表的表名，包含的列以及对应的类型。

### 默认值

&emsp;&emsp;可以为列分配一个默认值。当插入新行并且未为某些列指定值时，这些列将填充为各自的默认值。如果未明确声明默认值，则默认值为 NULL 值，NULL 值被视为表示未知数据。

&emsp;&emsp;在表定义中，默认值列在列数据类型之后，例如：

```sql
CREATE TABLE products (
    id integer,
    name varchar,
    price numeric DEFAULT 9.99
);
```

&emsp;&emsp;默认值可以是一个表达式，它将在插入默认值时进行计算 (而不是在创建表时)。一个常见的示例是 timestamp 列的默认值为`CURRENT_TIMESTAMP`，以便将其设置为行插入时间。另一个常见的示例是为每一行生成一个序列号。

### 生成列

&emsp;&emsp;生成列是一个特殊列，它总是根据其他列计算而来。因此，它对于列来说就像视图对于表一样。生成列有两种类型：存储的和虚拟的。存储的生成列在写入 (插入或更新) 时计算，并且占用存储空间，就像普通列一样。虚拟的生成列不占用存储空间，并且在读取时计算。因此，虚拟的生成列类似于视图，而存储的生成列类似于物化视图 (除了它总是自动更新)。PostgreSQL 目前仅实现存储的生成列。

&emsp;&emsp;创建生成列，在 CREATE TABLE 中使用`GENERATED ALWAYS AS`子句，例如：

```sql
CREATE TABLE people (
    ...,
    height_cm numeric,
    height_in numeric GENERATED ALWAYS AS (height_cm / 2.54) STORED
);
```

&emsp;&emsp;无法直接写入生成列：在 INSERT 或 UPDATE 命令中，无法为生成列指定值，但可以使用`DEFAULT`占位，以确保生成列使用其默认的计算方式来生成值。

&emsp;&emsp;如果未提供其他值，则在首次插入行时，列默认值将被评估一次。每当行更改且无法覆盖时，生成列都会被更新。列默认值可能不会引用表中的其他列，生成表达式通常会这样做。列默认值可以使用不稳定的函数，例如`random()`或引用当前时间的函数。生成列不允许这样做。

&emsp;&emsp;生成列有以下限制：

- 生成表达式只能使用不可变函数，并且不能使用子查询或以任何方式引用当前行以外的内容。
- 生成表达式不能引用另一个生成列。
- 生成表达式不能引用系统列，`tableoid`除外。
- 生成列不能具有列默认值或标识定义。
- 生成列不能是分区键的一部分。
- 外部表可以有生成列。
- 对于继承和分区：
  - 如果父列是生成列，则其子列也必须是生成列；但是，子列可以有不同的生成表达式。在插入或更新行期间实际应用的生成表达式是与行实际所在的表关联的表达式 (这与列默认值的行为不同：对于列默认值，应用查询中命名的表关联的默认值)。
  - 如果父列不是生成列，则其子列也不应该为生成列。
  - 对于继承表，如果在`CREATE TABLE ... INHERITS`中编写子列定义而不带任何`GENERATED`子句，则其`GENERATED`子句将自动从父级复制。`ALTER TABLE ... INHERIT`将坚持父列和子列在生成状态方面已经匹配，但不要求它们的生成表达式匹配。
  - 类似地，对于分区表，如果在`CREATE TABLE ... PARTITION OF`中编写子列定义而不带任何`GENERATED`子句，则其`GENERATED` 子句将自动从父级复制。`ALTER TABLE ... ATTACH PARTITION`将坚持父列和子列在生成状态方面已经匹配，但不要求它们的生成表达式匹配。
  - 在多重继承的情况下，如果一个父列是生成列，那么所有父列都必须是生成列。如果它们没有相同的生成表达式，那么必须明确指定子列的所需表达式。

&emsp;&emsp;使用生成列还需要考虑的因素：

- 生成列单独维护访问权限，与它们的基础列不同。因此，可以安排特定角色可以从生成列读取数据，但不能从基础列读取数据。
- 从概念上讲，生成列在`BEFORE`触发器运行后更新。因此在`BEFORE`触发器中对基础列进行的更改将反映在生成列中。但相反，不允许在`BEFORE`触发器中访问生成列。

### 约束

&emsp;&emsp;数据类型是一种限制表中可存储数据类型的方法。但是，对于许多应用程序而言，它们提供的约束太粗略。为此，SQL 允许对列和表定义约束。约束让用户可以根据需要对表中的数据进行尽可能多的控制。如果用户尝试将数据存储在违反约束的列中，则会引发错误。即使该值来自默认值定义，也适用此规则。

&emsp;&emsp;SQL 标准规定了列约束和表约束，列约束位于列之后，就跟默认值一样。列约束只应引用对应的列 (但是 PostgreSQL 不强制要求)。表约束独立于列，它是表定义中的一个单独条目。对于 PostgreSQL 来说，它们最终都是表约束。约束可以有一个名称，以便将来在修改或删除时引用，命名约束使用`CONSTRAINT`子句。

1. 检查约束

&emsp;&emsp;检查约束是最通用的约束类型，它允许指定某个列中的值必须满足布尔值 (真值) 表达式。例如约束价格非负：

```sql
CREATE TABLE products (
    id integer,
    name varchar,
    price numeric CHECK (price > 0)
);
```

&emsp;&emsp;或者使用表约束，并命名该约束：

```sql
CREATE TABLE products (
    id integer,
    name varchar,
    price numeric,
    CONSTRAINT chk_price CHECK (price > 0)
);
```

&emsp;&emsp;应当注意，如果检查表达式计算结果为真或空值，则满足检查约束。由于大多数表达式在任何操作数为空时都会计算为空值，因此它们不会阻止受约束列中的空值。若要确保列不包含空值，可以使用非空约束。

2. 非空约束

&emsp;&emsp;非空约束指定一列不得采用空值，非空约束必须是列约束。非空约束在功能上等效于检查约束`CHECK (column_name IS NOT NULL)`，但在 PostgreSQL 中创建显式非空约束更有效，缺点是无法为其命名。

```sql
CREATE TABLE products (
    id integer NOT NULL,
    name varchar NOT NULL,
    price numeric NOT NULL,
    CONSTRAINT chk_price CHECK (price > 0)
);
```

3. 唯一约束

&emsp;&emsp;唯一约束确保表中所有行的一列或一组列中包含的数据是唯一的。唯一约束可以是列约束 (约束一列)，也可以为表约束 (约束一组列)，例如：

```sql
CREATE TABLE products (
    id integer NOT NULL,
    name varchar NOT NULL,
    price numeric NOT NULL,
    CONSTRAINT chk_price CHECK (price > 0),
    CONSTRAINT uq_id_name UNIQUE (id, name)
);
```

&emsp;&emsp;唯一约束将自动在约束中列出的列或列组上创建唯一的 B 树索引。如果表中存在多于一行，其中包含在约束中包含的所有列的值相等，则会违反唯一约束。默认情况下，两个 NULL 值是不相等的。这意味着即使存在唯一约束，也可以存储在至少一个受约束列中包含空值的重复行。可以通过添加子句`NULLS NOT DISTINCT`来更改此行为，例如：

```sql
CREATE TABLE products (
    id integer NOT NULL,
    name varchar NOT NULL,
    price numeric NOT NULL,
    CONSTRAINT chk_price CHECK (price > 0),
    CONSTRAINT uq_id_name UNIQUE (id, name) NULLS NOT DISTINCT
);
```

4. 主键约束

&emsp;&emsp;主键约束表示一列或一组列可以用作表中行的唯一标识符。这要求值既唯一又非空。因此，下列定义等同：

```sql
CREATE TABLE products (
    id integer NOT NULL,
    name varchar NOT NULL,
    price numeric NOT NULL,
    CONSTRAINT uq_id UNIQUE (id)
);

CREATE TABLE products (
    id integer,
    name varchar NOT NULL,
    price numeric NOT NULL,
    CONSTRAINT pk_id PRIMARY KEY (id)
);
```

&emsp;&emsp;主键约束可以是列约束，也可以是表约束。添加主键将自动在主键中列出的列或列组上创建唯一的 B 树索引，并将强制将列标记为 NOT NULL (如果是列组，则其中的每个列都非空)。

&emsp;&emsp;一个表最多只能有一个主键 (可以有任何数量的唯一且非空约束，它们在功能上几乎是相同的东西，但只能将一个标识为主键)。关系数据库理论规定每个表都必须有一个主键，此规则不受 PostgreSQL 强制执行，但通常最好遵循它。

5. 外键约束

&emsp;&emsp;外键约束指定一列或一组列中的值必须与另一张表中某一行的值匹配 (即引用完整性)。外键约束可以是列约束，也可以是表约束，例如：

```sql
CREATE TABLE orders (
    id integer PRIMARY KEY,
    product integer REFERENCES products (id),
    quantity integer
);

CREATE TABLE orders (
    id integer PRIMARY KEY,
    product integer,
    quantity integer,
    FOREIGN KEY (product) REFERENCES products (id),
);
```

&emsp;&emsp;可以省略引用列列表，写成`... REFERENCES other_table`，此时会将该表的主键作为引用列。

&emsp;&emsp;外键约束中，约束列必须与引用列数量类型匹配。引用列必须是唯一且非空的 (但不必是主键)，但是约束列本身可以是空，这种情况下表示约束列不关联外部表的任何一行。此外，外部表还可以是自己，即自引用外键。

&emsp;&emsp;在关系数据库理论中，实现一对多的关系时，通常对多的一方使用外键约束。实现多对多的关系时，通常会建立一个新表，并在新表中分别对双方使用外键约束，例如：

```sql
CREATE TABLE order_items (
    product_id integer REFERENCES products (id),
    order_id integer REFERENCES orders (id),
    quantity integer,
    PRIMARY KEY (product_no, order_id)
);
```

&emsp;&emsp;为了维护引用完整性，当用户试图从外部表中删除一个正在被引用的行时，系统会根据在定义外键约束时存在的`ON DELETE`子句进行处理：

1. 删除失败：如果没有子句 (NO ACTION)。
2. 删除失败：如果使用了`ON DELETE RETRICT`子句。
3. 级联删除 (同时删除外键所在行)：如果使用了`ON DELETE CASCADE`子句。
4. 删除成功 (但将外键列设置为 NULL)：如果使用了`ON DELETE SET NULL`子句。
5. 删除成功 (但将外键列设置为默认值)：如果使用了`ON DELETE SET DEFAULT`子句。

&emsp;&emsp;NO ACTION 和 RESTRICT 的区别在于：NO ACTION 允许将检查推迟到事务的稍后时间，而 RESTRICT 不允许。

&emsp;&emsp;类似于 ON DELETE，还有`ON UPDATE`，当引用的列被更改 (更新) 时。除了 SET NULL 和 SET DEFAULT 不能指定列列表外，可能的操作是相同的。在这种情况下，CASCADE 表示引用的列的更新值应复制到引用行中。

## 删除表

&emsp;&emsp;使用 DROP TABLE 语句删除一个表：

```sql
DROP TABLE products;
```

&emsp;&emsp;删除一个不存在的表会引发错误，如果不确定表是否存在，使用：

```sql
DROP TABLE products IF EXISTS;
```

