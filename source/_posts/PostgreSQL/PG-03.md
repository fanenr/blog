---
title: PostgreSQL 03 - DDL
date: 2024-07-30 14:00:00
updated: 2024-07-31 14:00:00
tags:
  - DB
  - PostgreSQL
categories:
  - [DB, PostgreSQL]
---

&emsp;&emsp;PostgreSQL: The World\'s Most Advanced Open Source Relational Database.

<!-- more -->

&emsp;&emsp;DDL (Data Definition Language) 是 SQL (Structured Query Language) 的一部分，用于定义和管理数据库的结构。DDL 语句主要用于创建、修改和删除数据库对象，如表、索引、视图等。

&emsp;&emsp;创建和管理 PostgreSQL 数据库和模式的部分已经总结过了，本节主要总结表对象的管理。

## 创建表

&emsp;&emsp;关系数据库中的表非常像纸上的表格：它由行和列组成。列的数量和顺序是固定的，并且每列都有一个名称。行数是可变的 — 它反映了在给定时刻存储的数据量。SQL 不会对表中行的顺序做出任何保证。读取表时，除非明确请求排序，否则行将按未指定顺序显示。此外，SQL 不会为行分配唯一标识符，因此表中可能有多个完全相同行。

&emsp;&emsp;每列都有一个数据类型。数据类型限制了可以分配给一列的可能值集，并为存储在列中的数据分配语义，以便可用于计算。PostgreSQL 包含很多内置数据类型，用户还可以定义自己的数据类型。

&emsp;&emsp;使用 CREATE TABLE 语句创建一个新表：

```sql
CREATE TABLE products (
    id integer,
    name varchar,
    price numeric
);
```

&emsp;&emsp;至少应指明新表的表名，包含的列以及对应的类型。

### 默认值

&emsp;&emsp;可以为列分配一个默认值。当插入新行并且未为某些列指定值时，这些列将填充为各自的默认值。如果未明确声明默认值，则默认值为 NULL 值，NULL 值被视为表示未知数据。

&emsp;&emsp;在表定义中，默认值列在列数据类型之后，例如：

```sql
CREATE TABLE products (
    id integer,
    name varchar,
    price numeric DEFAULT 9.99
);
```

&emsp;&emsp;默认值可以是一个表达式，它将在插入默认值时进行计算 (而不是在创建表时)。一个常见的示例是 timestamp 列的默认值为`CURRENT_TIMESTAMP`，以便将其设置为行插入时间。另一个常见的示例是为每一行生成一个序列号。

### 生成列

&emsp;&emsp;生成列是一个特殊列，它总是根据其他列计算而来。因此，它对于列来说就像视图对于表一样。生成列有两种类型：存储的和虚拟的。存储的生成列在写入 (插入或更新) 时计算，并且占用存储空间，就像普通列一样。虚拟的生成列不占用存储空间，并且在读取时计算。因此，虚拟的生成列类似于视图，而存储的生成列类似于物化视图 (除了它总是自动更新)。PostgreSQL 目前仅实现存储的生成列。

&emsp;&emsp;创建生成列，在 CREATE TABLE 中使用`GENERATED ALWAYS AS`子句，例如：

```sql
CREATE TABLE people (
    ...,
    height_cm numeric,
    height_in numeric GENERATED ALWAYS AS (height_cm / 2.54) STORED
);
```

&emsp;&emsp;无法直接写入生成列：在 INSERT 或 UPDATE 命令中，无法为生成列指定值，但可以使用`DEFAULT`占位，以确保生成列使用其默认的计算方式来生成值。

&emsp;&emsp;如果未提供其他值，则在首次插入行时，列默认值将被评估一次。每当行更改且无法覆盖时，生成列都会被更新。列默认值可能不会引用表中的其他列，生成表达式通常会这样做。列默认值可以使用不稳定的函数，例如`random()`或引用当前时间的函数。生成列不允许这样做。

&emsp;&emsp;生成列有以下限制：

- 生成表达式只能使用不可变函数，并且不能使用子查询或以任何方式引用当前行以外的内容。
- 生成表达式不能引用另一个生成列。
- 生成表达式不能引用系统列，`tableoid`除外。
- 生成列不能具有列默认值或标识定义。
- 生成列不能是分区键的一部分。
- 外部表可以有生成列。
- 对于继承和分区：
  - 如果父列是生成列，则其子列也必须是生成列；但是，子列可以有不同的生成表达式。在插入或更新行期间实际应用的生成表达式是与行实际所在的表关联的表达式 (这与列默认值的行为不同：对于列默认值，应用查询中命名的表关联的默认值)。
  - 如果父列不是生成列，则其子列也不应该为生成列。
  - 对于继承表，如果在`CREATE TABLE ... INHERITS`中编写子列定义而不带任何`GENERATED`子句，则其`GENERATED`子句将自动从父级复制。`ALTER TABLE ... INHERIT`将坚持父列和子列在生成状态方面已经匹配，但不要求它们的生成表达式匹配。
  - 类似地，对于分区表，如果在`CREATE TABLE ... PARTITION OF`中编写子列定义而不带任何`GENERATED`子句，则其`GENERATED` 子句将自动从父级复制。`ALTER TABLE ... ATTACH PARTITION`将坚持父列和子列在生成状态方面已经匹配，但不要求它们的生成表达式匹配。
  - 在多重继承的情况下，如果一个父列是生成列，那么所有父列都必须是生成列。如果它们没有相同的生成表达式，那么必须明确指定子列的所需表达式。

&emsp;&emsp;使用生成列还需要考虑的因素：

- 生成列单独维护访问权限，与它们的基础列不同。因此，可以安排特定角色可以从生成列读取数据，但不能从基础列读取数据。
- 从概念上讲，生成列在`BEFORE`触发器运行后更新。因此在`BEFORE`触发器中对基础列进行的更改将反映在生成列中。但相反，不允许在`BEFORE`触发器中访问生成列。

### 约束

&emsp;&emsp;数据类型是一种限制表中可存储数据类型的方法。但是，对于许多应用程序而言，它们提供的约束太粗略。为此，SQL 允许对列和表定义约束。约束让用户可以根据需要对表中的数据进行尽可能多的控制。如果用户尝试将数据存储在违反约束的列中，则会引发错误。即使该值来自默认值定义，也适用此规则。

&emsp;&emsp;SQL 标准规定了列约束和表约束，列约束位于列之后，就跟默认值一样。列约束只应引用对应的列 (但是 PostgreSQL 不强制要求)。表约束独立于列，它是表定义中的一个单独条目。对于 PostgreSQL 来说，它们最终都是表约束。约束可以有一个名称，以便将来在修改或删除时引用，命名约束使用`CONSTRAINT`子句。

1. 检查约束

&emsp;&emsp;检查约束是最通用的约束类型，它允许指定某个列中的值必须满足布尔值 (真值) 表达式。例如约束价格非负：

```sql
CREATE TABLE products (
    id integer,
    name varchar,
    price numeric CHECK (price > 0)
);
```

&emsp;&emsp;或者使用表约束，并命名该约束：

```sql
CREATE TABLE products (
    id integer,
    name varchar,
    price numeric,
    CONSTRAINT chk_price CHECK (price > 0)
);
```

&emsp;&emsp;应当注意，如果检查表达式计算结果为真或空值，则满足检查约束。由于大多数表达式在任何操作数为空时都会计算为空值，因此它们不会阻止受约束列中的空值。若要确保列不包含空值，可以使用非空约束。

2. 非空约束

&emsp;&emsp;非空约束指定一列不得采用空值，非空约束必须是列约束。非空约束在功能上等效于检查约束`CHECK (column_name IS NOT NULL)`，但在 PostgreSQL 中创建显式非空约束更有效，缺点是无法为其命名。

```sql
CREATE TABLE products (
    id integer NOT NULL,
    name varchar NOT NULL,
    price numeric NOT NULL,
    CONSTRAINT chk_price CHECK (price > 0)
);
```

3. 唯一约束

&emsp;&emsp;唯一约束确保表中所有行的一列或一组列中包含的数据是唯一的。唯一约束可以是列约束 (约束一列)，也可以为表约束 (约束一组列)，例如：

```sql
CREATE TABLE products (
    id integer NOT NULL,
    name varchar NOT NULL,
    price numeric NOT NULL,
    CONSTRAINT chk_price CHECK (price > 0),
    CONSTRAINT uq_id_name UNIQUE (id, name)
);
```

&emsp;&emsp;唯一约束将自动在约束中列出的列或列组上创建唯一的 B 树索引。如果表中存在多于一行，其中包含在约束中包含的所有列的值相等，则会违反唯一约束。默认情况下，两个 NULL 值是不相等的。这意味着即使存在唯一约束，也可以存储在至少一个受约束列中包含空值的重复行。可以通过添加子句`NULLS NOT DISTINCT`来更改此行为，例如：

```sql
CREATE TABLE products (
    id integer NOT NULL,
    name varchar NOT NULL,
    price numeric NOT NULL,
    CONSTRAINT chk_price CHECK (price > 0),
    CONSTRAINT uq_id_name UNIQUE (id, name) NULLS NOT DISTINCT
);
```

4. 主键约束

&emsp;&emsp;主键约束表示一列或一组列可以用作表中行的唯一标识符。这要求值既唯一又非空。因此，下列定义等同：

```sql
CREATE TABLE products (
    id integer NOT NULL,
    name varchar NOT NULL,
    price numeric NOT NULL,
    CONSTRAINT uq_id UNIQUE (id)
);

CREATE TABLE products (
    id integer,
    name varchar NOT NULL,
    price numeric NOT NULL,
    CONSTRAINT pk_id PRIMARY KEY (id)
);
```

&emsp;&emsp;主键约束可以是列约束，也可以是表约束。添加主键将自动在主键中列出的列或列组上创建唯一的 B 树索引，并将强制将列标记为 NOT NULL (如果是列组，则其中的每个列都非空)。

&emsp;&emsp;一个表最多只能有一个主键 (可以有任何数量的唯一且非空约束，它们在功能上几乎是相同的东西，但只能将一个标识为主键)。关系数据库理论规定每个表都必须有一个主键，此规则不受 PostgreSQL 强制执行，但通常最好遵循它。

5. 外键约束

&emsp;&emsp;外键约束指定一列或一组列中的值必须与另一张表中某一行的值匹配 (即引用完整性)。外键约束可以是列约束，也可以是表约束，例如：

```sql
CREATE TABLE orders (
    id integer PRIMARY KEY,
    product integer REFERENCES products (id),
    quantity integer
);

CREATE TABLE orders (
    id integer PRIMARY KEY,
    product integer,
    quantity integer,
    FOREIGN KEY (product) REFERENCES products (id),
);
```

&emsp;&emsp;可以省略引用列列表，写成`... REFERENCES other_table`，此时会将该表的主键作为引用列。

&emsp;&emsp;外键约束中，约束列必须与引用列数量类型匹配。引用列必须是唯一且非空的 (但不必是主键)，但是约束列本身可以是空，这种情况下表示约束列不关联外部表的任何一行。此外，外部表还可以是自己，即自引用外键。

&emsp;&emsp;在关系数据库理论中，实现一对多的关系时，通常对多的一方使用外键约束。实现多对多的关系时，通常会建立一个新表，并在新表中分别对双方使用外键约束，例如：

```sql
CREATE TABLE order_items (
    product_id integer REFERENCES products (id),
    order_id integer REFERENCES orders (id),
    quantity integer,
    PRIMARY KEY (product_no, order_id)
);
```

&emsp;&emsp;为了维护引用完整性，当用户试图从外部表中删除一个正在被引用的行时，系统会根据在定义外键约束时存在的`ON DELETE`子句进行处理：

1. 删除失败：如果没有子句 (NO ACTION)。
2. 删除失败：如果使用了`ON DELETE RETRICT`子句。
3. 级联删除 (同时删除外键所在行)：如果使用了`ON DELETE CASCADE`子句。
4. 删除成功 (但将外键列设置为 NULL)：如果使用了`ON DELETE SET NULL`子句。
5. 删除成功 (但将外键列设置为默认值)：如果使用了`ON DELETE SET DEFAULT`子句。

&emsp;&emsp;NO ACTION 和 RESTRICT 的区别在于：NO ACTION 允许将检查推迟到事务的稍后时间，而 RESTRICT 不允许。

&emsp;&emsp;类似于 ON DELETE，还有`ON UPDATE`，当引用的列被更改 (更新) 时。除了 SET NULL 和 SET DEFAULT 不能指定列列表外，可能的操作是相同的。在这种情况下，CASCADE 表示引用的列的更新值应复制到引用行中。


## 修改表

&emsp;&emsp;修改表结构最直接的方法是删除原表然后重新建表，但当表被外部对象引用时，这种方式并不方便。另一种方式是使用`ALTER TABLE`命令，直接在原表的基础上进行修改。

1. 添加列

&emsp;&emsp;使用`ADD COLUMN colname coltype ...`子命令向表中添加一列：

```sql
ALTER TABLE products ADD COLUMN description text CHECK (description <> '');
```

&emsp;&emsp;在添加列时，还可以为其指定列约束，就跟 CREATE TABLE 一样。

&emsp;&emsp;从 PostgreSQL 11 开始，添加具有常量默认值的新列时不再需要更新表中的每一行。相反，将在下次访问该行时返回默认值，并在重写表时应用该默认值，即使在大型表上，也能使 ALTER TABLE 非常快速。但如果默认值不稳定 (如`clock_timestamp()`)，则需要使用在执行`ALTER TABLE`时计算的值来更新每一行。

2. 删除列

&emsp;&emsp;使用`DROP COLUMN colname`子命令从表中删除一列：

```sql
ALTER TABLE products DROP COLUMN description;
```

&emsp;&emsp;列中的任何数据都将消失，涉及该列的表约束也将被删除。但如果该列被另一张表的外部键约束引用，系统将不会静默地删除该约束，可以使用`CASCADE`来授权删除所有依赖于该列的内容：

```sql
ALTER TABLE products DROP COLUMN description CASCADE;
```

3. 重命名列

&emsp;&emsp;使用`RENAME COLUME colname TO newname`子命令重命名列名：

```sql
ALTER TABLE products RENAME COLUMN product_no TO product_number;
```

4. 重命名表

&emsp;&emsp;使用`RENAME TO`子命令重命名表名：

```sql
ALTER TABLE products RENAME TO products2;
```

5. 添加约束

&emsp;&emsp;使用`ADD ...`子命令向表中添加表约束，例如：

```sql
ALTER TABLE products ADD CHECK (name <> '');
ALTER TABLE products ADD CONSTRAINT some_name UNIQUE (product_no);
ALTER TABLE products ADD FOREIGN KEY (product_group_id) REFERENCES product_groups;
```

&emsp;&emsp;添加非空约束 (不能写为表约束)，使用：

```sql
ALTER TABLE products ALTER COLUMN product_no SET NOT NULL;
```

&emsp;&emsp;约束将立即被检查，因此表数据必须满足约束才能被添加。

6. 删除约束

&emsp;&emsp;删除约束时需要知道其名称。如果已经为它命名，那就很容易，否则系统会分配一个生成名称，需要手动找出它。元命令`\d tablename`在这里可能会有帮助。然后使用`DROP CONSTRAINT consname`子命令删除它：

```sql
ALTER TABLE products DROP CONSTRAINT some_name;
```

&emsp;&emsp;注意，如`$2`这样生成的约束名称，需要使用双引号扩起来使其成为一个有效的标识符。

&emsp;&emsp;与删除列一样，如果要删除其他内容所依赖的约束，需要添加`CASCADE`。

&emsp;&emsp;因为非空约束没有名称，因此删除非空约束需使用`ALTER COLUMN colname DROP NOT NULL`子命令：

```sql
ALTER TABLE products ALTER COLUMN product_no DROP NOT NULL;
```

7. 修改列默认值

&emsp;&emsp;要为列设置新的默认值，使用`ALTER COLUMN colname SET DEFAULT ...`子命令：

```sql
ALTER TABLE products ALTER COLUMN price SET DEFAULT 7.77;
```

&emsp;&emsp;注意，这不会影响表中的任何现有行，它只会更改未来`INSERT`命令的默认值。

&emsp;&emsp;要删除默认值，使用`ALTER COLUMN colname DROP DEFAULT`子命令：

```sql
ALTER TABLE products ALTER COLUMN price DROP DEFAULT;
```

&emsp;&emsp;这实际上与将默认值设置为 NULL 相同。

8. 修改列数据类型

&emsp;&emsp;要将列转换为不同的数据类型，使用`ALTER COLUMN colname TYPE ...`子命令：

```sql
ALTER TABLE products ALTER COLUMN price TYPE numeric(10, 2);
```

&emsp;&emsp;只有当列中的每个现有条目都可以通过隐式转换转换为新类型时，此操作才成功。如果需要更复杂的转换，需要添加一个`USING`子句，该子句指定如何从旧值计算新值。

&emsp;&emsp;PostgreSQL 将尝试将列的默认值 (如果有) 转换为新类型，以及涉及该列的任何约束。但这些转换可能会失败，或者可能会产生令人惊讶的结果。在更改列的类型之前，通常最好删除列上的任何约束，然后在之后添加适当修改的约束。

## 删除表

&emsp;&emsp;使用 DROP TABLE 语句删除一个表：

```sql
DROP TABLE products;
```

&emsp;&emsp;删除一个不存在的表会引发错误，如果不确定表是否存在，使用：

```sql
DROP TABLE products IF EXISTS;
```
